using AssetHelperLib.BundleTools;
using AssetsTools.NET.Extra;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace AssetHelperLib.Repacking;

/// <summary>
/// Base class for repacking strategies.
/// </summary>
public abstract class SceneRepacker
{
    /// <summary>
    /// String indicating how repacking was done.
    /// </summary>
    protected virtual string RepackStrategy => GetType().Name;

    /// <summary>
    /// Generate sensible cab and bundle names for the given bundle.
    /// 
    /// These don't matter, but the ones generated by this function look like the ones made by unity.
    /// </summary>
    protected static void GetDefaultBundleNames(
        RepackingParams repackingParams,
        out string cabName,
        out string bundleName)
    {
        const string salt = "AssetHelperSalt\n";

        using SHA256 sha256 = SHA256.Create();

        StringBuilder inputSb = new();
        inputSb.AppendLine(salt);
        inputSb.AppendLine(repackingParams.SceneBundlePath ?? string.Empty);

        foreach (string name in repackingParams.ObjectNames)
        {
            inputSb.AppendLine($"\n{name}");
        }

        inputSb.AppendLine(repackingParams.OutBundlePath);

        string saltedInput = inputSb.ToString();

        byte[] inputBytes = Encoding.UTF8.GetBytes(saltedInput);
        byte[] hashBytes = sha256.ComputeHash(inputBytes);

        StringBuilder sb = new(64);
        foreach (byte b in hashBytes)
        {
            sb.Append(b.ToString("x2"));
        }

        string fullHash = sb.ToString();

        cabName = $"CAB-{fullHash.Substring(0, 32)}";
        bundleName = $"{fullHash.Substring(32, 32)}.bundle";
    }

    /// <inheritdoc cref="Repack(RepackingParams, ref RepackedBundleData)" />
    public RepackedBundleData Repack(RepackingParams repackingParams)
    {
        RepackedBundleData outData = new();
        Repack(repackingParams, ref outData);
        return outData;
    }

    /// <summary>
    /// Create a bundle that can be used to spawn objects from the provided scene bundle.
    /// </summary>
    public void Repack(
        RepackingParams repackingParams,
        ref RepackedBundleData outData)
    {
        outData.RepackStrategy = RepackStrategy;

        GetDefaultBundleNames(repackingParams, out string cabName, out string bundleName);
        outData.CabName ??= cabName;
        outData.BundleName ??= bundleName;

        AssetsManager mgr = BundleUtils.CreateDefaultManager();

        using MemoryStream ms = new(File.ReadAllBytes(repackingParams.SceneBundlePath));
        BundleFileInstance sceneBun = mgr.LoadBundleFile(ms, repackingParams.SceneBundlePath);

        if (!mgr.TryFindAssetsFiles(sceneBun, out BundleUtils.SceneBundleInfo sceneBundleInfo))
        {
            throw new NotSupportedException($"Could not find assets files for {repackingParams.SceneBundlePath}");
        }

        AssetsFileInstance mainSceneAfileInst = mgr.LoadAssetsFileFromBundle(sceneBun, sceneBundleInfo.mainAfileInstIndex);
        AssetsFileInstance sceneSharedAssetsFileInst = mgr.LoadAssetsFileFromBundle(sceneBun, sceneBundleInfo.sharedAssetsAfileIndex);

        RepackingContext ctx = new()
        {
            SceneAssetsManager = mgr,
            SceneBundleFileInstance = sceneBun,
            MainAssetsFileInstance = mainSceneAfileInst,
            SharedAssetsFileInstance = sceneSharedAssetsFileInst,
            SceneBundleInfo = sceneBundleInfo,
        };

        Run(ctx, repackingParams, outData);

        mgr.UnloadAll();
    }

    /// <summary>
    /// Run the repacking operation.
    /// </summary>
    protected abstract void Run(
        RepackingContext ctx,
        RepackingParams repackingParams,
        RepackedBundleData outData
        );
}
